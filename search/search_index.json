{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pzp","title":"Pzp Docs"},{"location":"#pzp","text":"","title":"pzp"},{"location":"license/","text":"The MIT License (MIT) Copyright (c) 2013-2022 Andrea Bonomi andrea.bonomi@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/ansi/","text":"BLACK = f ' { ESC } [30m' module-attribute Black foreground color BLACK_BG = f ' { ESC } [40m' module-attribute Black background color BLUE = f ' { ESC } [34m' module-attribute Blue foreground color BLUE_BG = f ' { ESC } [44m' module-attribute Blue background color BOLD = f ' { ESC } [1m' module-attribute Set bold mode CURSOR_RESTORE_POS = f ' { ESC } 8' module-attribute Restores the cursor to the last saved position CURSOR_SAVE_POS = f ' { ESC } 7' module-attribute Save cursor position CYAN = f ' { ESC } [36m' module-attribute Cyan foreground color CYAN_BG = f ' { ESC } [46m' module-attribute Cyan background color ERASE_LINE = f ' { ESC } [2K' module-attribute Erase the entire line GREEN = f ' { ESC } [32m' module-attribute Green foreground color GREEN_BG = f ' { ESC } [42m' module-attribute Green background color NEGATIVE = f ' { ESC } [7m' module-attribute Set inverse mode NORMAL = f ' { ESC } [0m' module-attribute Reset styles and colors PURPLE = f ' { ESC } [35m' module-attribute Purple foreground color PURPLE_BG = f ' { ESC } [45m' module-attribute Purple background color RED = f ' { ESC } [31m' module-attribute Red foreground color RED_BG = f ' { ESC } [41m' module-attribute Red background color WHITE = f ' { ESC } [37m' module-attribute White foreground color WHITE_BG = f ' { ESC } [47m' module-attribute White background color YELLOW = f ' { ESC } [33m' module-attribute Yellow foreground color YELLOW_BG = f ' { ESC } [43m' module-attribute Yellow background color","title":"pzp.ansi"},{"location":"api/ansi/#pzp.ansi.BLACK","text":"Black foreground color","title":"BLACK"},{"location":"api/ansi/#pzp.ansi.BLACK_BG","text":"Black background color","title":"BLACK_BG"},{"location":"api/ansi/#pzp.ansi.BLUE","text":"Blue foreground color","title":"BLUE"},{"location":"api/ansi/#pzp.ansi.BLUE_BG","text":"Blue background color","title":"BLUE_BG"},{"location":"api/ansi/#pzp.ansi.BOLD","text":"Set bold mode","title":"BOLD"},{"location":"api/ansi/#pzp.ansi.CURSOR_RESTORE_POS","text":"Restores the cursor to the last saved position","title":"CURSOR_RESTORE_POS"},{"location":"api/ansi/#pzp.ansi.CURSOR_SAVE_POS","text":"Save cursor position","title":"CURSOR_SAVE_POS"},{"location":"api/ansi/#pzp.ansi.CYAN","text":"Cyan foreground color","title":"CYAN"},{"location":"api/ansi/#pzp.ansi.CYAN_BG","text":"Cyan background color","title":"CYAN_BG"},{"location":"api/ansi/#pzp.ansi.ERASE_LINE","text":"Erase the entire line","title":"ERASE_LINE"},{"location":"api/ansi/#pzp.ansi.GREEN","text":"Green foreground color","title":"GREEN"},{"location":"api/ansi/#pzp.ansi.GREEN_BG","text":"Green background color","title":"GREEN_BG"},{"location":"api/ansi/#pzp.ansi.NEGATIVE","text":"Set inverse mode","title":"NEGATIVE"},{"location":"api/ansi/#pzp.ansi.NORMAL","text":"Reset styles and colors","title":"NORMAL"},{"location":"api/ansi/#pzp.ansi.PURPLE","text":"Purple foreground color","title":"PURPLE"},{"location":"api/ansi/#pzp.ansi.PURPLE_BG","text":"Purple background color","title":"PURPLE_BG"},{"location":"api/ansi/#pzp.ansi.RED","text":"Red foreground color","title":"RED"},{"location":"api/ansi/#pzp.ansi.RED_BG","text":"Red background color","title":"RED_BG"},{"location":"api/ansi/#pzp.ansi.WHITE","text":"White foreground color","title":"WHITE"},{"location":"api/ansi/#pzp.ansi.WHITE_BG","text":"White background color","title":"WHITE_BG"},{"location":"api/ansi/#pzp.ansi.YELLOW","text":"Yellow foreground color","title":"YELLOW"},{"location":"api/ansi/#pzp.ansi.YELLOW_BG","text":"Yellow background color","title":"YELLOW_BG"},{"location":"api/finder/","text":"DEFAULT_POINTER = '>' module-attribute Default pointer DEFAULT_PROMPT = '>' module-attribute Default input prompt Finder Source code in pzp/finder.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class Finder : def __init__ ( self , candidates : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], fullscreen : bool = True , height : Optional [ int ] = None , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , pointer_str : str = DEFAULT_POINTER , prompt_str : str = DEFAULT_PROMPT , output_stream : TextIO = sys . stderr , ): \"\"\" Initializate Finder object Args: candidates: Candidates fullscreen: Full screen mode height: Finder window height format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info pointer_str: Pointer to the current line prompt_str: Input prompt \"\"\" self . fullscreen = fullscreen self . height = height self . format_fn = format_fn self . layout : Layout = layout self . info_style : InfoStyle = info_style self . pointer_str = pointer_str self . no_pointer_str = \" \" * len ( pointer_str ) self . prompt_str = prompt_str self . output_stream = output_stream self . keycodes_actions : Dict [ str , str ] = dict ( ChainMap ( * [{ KEYS [ v ]: k for v in vlist } for k , vlist in ACTIONS . items ()])) # Get the candidates if isinstance ( candidates , Iterator ) or callable ( candidates ): self . get_items_fn : Union [ None , Callable [[], Sequence [ Any ]], Iterator [ Any ]] = candidates self . candidates : Sequence [ Any ] = [] else : self . get_items_fn = None self . candidates = candidates def show ( self , input : Optional [ str ] = None ) -> Any : \"\"\" Open pzp and return the selected element Args: input: initial search string Returns: item: the selected item \"\"\" self . setup ( input = input ) try : while True : self . process_key ( get_char ()) self . apply_filter () self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . cleanup () @property def screen_items ( self ) -> Sequence [ Any ]: \"Candidates to be displayed on the screen\" return self . matching_candidates [ self . offset : self . offset + self . max_candidates ] @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) @property def candidates_len ( self ) -> int : \"Number of candidates\" return len ( self . candidates ) @property def matching_candidates_len ( self ) -> int : \"Number of matching candidates\" return len ( self . matching_candidates ) @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0 @property def prompt_lines ( self ) -> int : \"Number of prompt lines\" return len ( self . prompt_str . split ( f \" { NL } \" )) @property def margin_lines ( self ) -> int : \"Screen margin\" return self . info_lines + self . prompt_lines @property def max_candidates ( self ) -> int : \"Maximun number of candidates printables on the screen\" return self . screen . height - self . margin_lines def setup ( self , input : Optional [ str ] = None ) -> None : \"\"\" Setup Finder execution Args: input: initial search string \"\"\" self . input : str = input or \"\" # Load the candidate list self . refresh_candidates () # Calculate the required height and setup the screen height = self . height if self . height is not None else self . candidates_len + self . margin_lines self . screen : Screen = Screen ( stream = self . output_stream , fullscreen = self . fullscreen , height = height ) # Filter the items, calculate the screen offset self . apply_filter () self . update_screen ( erase = False ) def refresh_candidates ( self ) -> None : \"Load/reload the candidate list\" # Get items if isinstance ( self . get_items_fn , Iterator ): self . candidates = list ( self . get_items_fn ) elif callable ( self . get_items_fn ): self . candidates = list ( self . get_items_fn ()) # Reset selected/offset self . selected : int = 0 self . offset : int = 0 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"page-down\" : # Move one page down self . selected = self . selected + self . max_candidates elif action == \"page-up\" : # Move one page up self . selected = self . selected - self . max_candidates elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch def apply_filter ( self ) -> None : \"Filter the items, calculate the screen offset\" self . matching_candidates : Sequence [ Any ] = list ( filter ( self . match , self . candidates )) # Adject selected self . selected = max ( min ( self . selected , self . matching_candidates_len - 1 ), 0 ) # Calculate the offset if self . selected >= self . offset + self . max_candidates : self . offset = self . selected - self . max_candidates + 1 elif self . selected < self . offset : self . offset = self . selected if self . offset < 0 : self . offset = 0 def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_screen () if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush () def print_items ( self ) -> None : for i , item in enumerate ( self . screen_items ): is_selected = i + self . offset == self . selected if is_selected : self . screen . write ( f \" { ERASE_LINE }{ RED }{ BOLD }{ BLACK_BG }{ self . pointer_str }{ NORMAL } { BOLD }{ self . format_fn ( item ) }{ NORMAL }{ NL } \" ) else : self . screen . write ( f \" { ERASE_LINE }{ BLACK_BG }{ self . no_pointer_str }{ NORMAL } { self . format_fn ( item ) }{ NL } \" ) def print_empty_lines ( self ) -> None : if self . fullscreen : lines = self . max_candidates - self . screen_items_len else : lines = min ( self . candidates_len , self . max_candidates - self . screen_items_len ) self . screen . write ( f \" { NL } \" * lines ) def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ self . matching_candidates_len } / { self . candidates_len }{ NORMAL }{ NL } \" ) def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN }{ self . prompt_str }{ NORMAL } { self . input } \" ) def match ( self , item : Any ) -> bool : return self . input . lower () in self . format_fn ( item ) . lower () def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . matching_candidates [ self . selected ] except IndexError : return None __init__ ( candidates , fullscreen = True , height = None , format_fn = lambda x : str ( x ), layout = Layout . REVERSE_LIST , info_style = InfoStyle . DEFAULT , pointer_str = DEFAULT_POINTER , prompt_str = DEFAULT_PROMPT , output_stream = sys . stderr ) Initializate Finder object Parameters: Name Type Description Default candidates Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]] Candidates required fullscreen bool Full screen mode True height Optional [ int ] Finder window height None format_fn Callable [[ Any ], str ] Items format function lambda x: str(x) layout Layout Finder layout Layout.REVERSE_LIST info_style InfoStyle Determines the display style of finder info InfoStyle.DEFAULT pointer_str str Pointer to the current line DEFAULT_POINTER prompt_str str Input prompt DEFAULT_PROMPT Source code in pzp/finder.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , candidates : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], fullscreen : bool = True , height : Optional [ int ] = None , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , pointer_str : str = DEFAULT_POINTER , prompt_str : str = DEFAULT_PROMPT , output_stream : TextIO = sys . stderr , ): \"\"\" Initializate Finder object Args: candidates: Candidates fullscreen: Full screen mode height: Finder window height format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info pointer_str: Pointer to the current line prompt_str: Input prompt \"\"\" self . fullscreen = fullscreen self . height = height self . format_fn = format_fn self . layout : Layout = layout self . info_style : InfoStyle = info_style self . pointer_str = pointer_str self . no_pointer_str = \" \" * len ( pointer_str ) self . prompt_str = prompt_str self . output_stream = output_stream self . keycodes_actions : Dict [ str , str ] = dict ( ChainMap ( * [{ KEYS [ v ]: k for v in vlist } for k , vlist in ACTIONS . items ()])) # Get the candidates if isinstance ( candidates , Iterator ) or callable ( candidates ): self . get_items_fn : Union [ None , Callable [[], Sequence [ Any ]], Iterator [ Any ]] = candidates self . candidates : Sequence [ Any ] = [] else : self . get_items_fn = None self . candidates = candidates apply_filter () Filter the items, calculate the screen offset Source code in pzp/finder.py 231 232 233 234 235 236 237 238 239 240 241 242 def apply_filter ( self ) -> None : \"Filter the items, calculate the screen offset\" self . matching_candidates : Sequence [ Any ] = list ( filter ( self . match , self . candidates )) # Adject selected self . selected = max ( min ( self . selected , self . matching_candidates_len - 1 ), 0 ) # Calculate the offset if self . selected >= self . offset + self . max_candidates : self . offset = self . selected - self . max_candidates + 1 elif self . selected < self . offset : self . offset = self . selected if self . offset < 0 : self . offset = 0 candidates_len () property Number of candidates Source code in pzp/finder.py 150 151 152 153 @property def candidates_len ( self ) -> int : \"Number of candidates\" return len ( self . candidates ) info_lines () property Number of info lines Source code in pzp/finder.py 160 161 162 163 @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0 margin_lines () property Screen margin Source code in pzp/finder.py 170 171 172 173 @property def margin_lines ( self ) -> int : \"Screen margin\" return self . info_lines + self . prompt_lines matching_candidates_len () property Number of matching candidates Source code in pzp/finder.py 155 156 157 158 @property def matching_candidates_len ( self ) -> int : \"Number of matching candidates\" return len ( self . matching_candidates ) max_candidates () property Maximun number of candidates printables on the screen Source code in pzp/finder.py 175 176 177 178 @property def max_candidates ( self ) -> int : \"Maximun number of candidates printables on the screen\" return self . screen . height - self . margin_lines prepare_result () Output the selected item, if any Source code in pzp/finder.py 284 285 286 287 288 289 def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . matching_candidates [ self . selected ] except IndexError : return None print_info () Print info Source code in pzp/finder.py 272 273 274 275 def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ self . matching_candidates_len } / { self . candidates_len }{ NORMAL }{ NL } \" ) print_prompt () Print prompt Source code in pzp/finder.py 277 278 279 def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN }{ self . prompt_str }{ NORMAL } { self . input } \" ) process_key ( ch ) Process the pressed key Source code in pzp/finder.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"page-down\" : # Move one page down self . selected = self . selected + self . max_candidates elif action == \"page-up\" : # Move one page up self . selected = self . selected - self . max_candidates elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch prompt_lines () property Number of prompt lines Source code in pzp/finder.py 165 166 167 168 @property def prompt_lines ( self ) -> int : \"Number of prompt lines\" return len ( self . prompt_str . split ( f \" { NL } \" )) refresh_candidates () Load/reload the candidate list Source code in pzp/finder.py 197 198 199 200 201 202 203 204 205 206 def refresh_candidates ( self ) -> None : \"Load/reload the candidate list\" # Get items if isinstance ( self . get_items_fn , Iterator ): self . candidates = list ( self . get_items_fn ) elif callable ( self . get_items_fn ): self . candidates = list ( self . get_items_fn ()) # Reset selected/offset self . selected : int = 0 self . offset : int = 0 screen_items () property Candidates to be displayed on the screen Source code in pzp/finder.py 140 141 142 143 @property def screen_items ( self ) -> Sequence [ Any ]: \"Candidates to be displayed on the screen\" return self . matching_candidates [ self . offset : self . offset + self . max_candidates ] screen_items_len () property Number of items on the screen Source code in pzp/finder.py 145 146 147 148 @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) setup ( input = None ) Setup Finder execution Parameters: Name Type Description Default input Optional [ str ] initial search string None Source code in pzp/finder.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def setup ( self , input : Optional [ str ] = None ) -> None : \"\"\" Setup Finder execution Args: input: initial search string \"\"\" self . input : str = input or \"\" # Load the candidate list self . refresh_candidates () # Calculate the required height and setup the screen height = self . height if self . height is not None else self . candidates_len + self . margin_lines self . screen : Screen = Screen ( stream = self . output_stream , fullscreen = self . fullscreen , height = height ) # Filter the items, calculate the screen offset self . apply_filter () self . update_screen ( erase = False ) show ( input = None ) Open pzp and return the selected element Parameters: Name Type Description Default input Optional [ str ] initial search string None Returns: Name Type Description item Any the selected item Source code in pzp/finder.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def show ( self , input : Optional [ str ] = None ) -> Any : \"\"\" Open pzp and return the selected element Args: input: initial search string Returns: item: the selected item \"\"\" self . setup ( input = input ) try : while True : self . process_key ( get_char ()) self . apply_filter () self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . cleanup () update_screen ( erase = True ) Update the screen - erase the old items, print the filtered items and the prompt Source code in pzp/finder.py 244 245 246 247 248 249 250 251 252 253 def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_screen () if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush () InfoStyle Bases: Enum Display style of finder info Source code in pzp/finder.py 64 65 66 67 68 69 70 class InfoStyle ( Enum ): \"Display style of finder info\" DEFAULT = \"default\" \" Display on the next line to the prompt \" HIDDEN = \"hidden\" \" Do not display finder info\" DEFAULT = 'default' class-attribute Display on the next line to the prompt HIDDEN = 'hidden' class-attribute Do not display finder info Layout Bases: Enum Finder layouts Source code in pzp/finder.py 57 58 59 60 61 class Layout ( Enum ): \"Finder layouts\" REVERSE_LIST = \"reverse-list\" \" Display from the top of the screen, prompt at the bottom \" REVERSE_LIST = 'reverse-list' class-attribute Display from the top of the screen, prompt at the bottom","title":"pzp.finder"},{"location":"api/finder/#pzp.finder.DEFAULT_POINTER","text":"Default pointer","title":"DEFAULT_POINTER"},{"location":"api/finder/#pzp.finder.DEFAULT_PROMPT","text":"Default input prompt","title":"DEFAULT_PROMPT"},{"location":"api/finder/#pzp.finder.Finder","text":"Source code in pzp/finder.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 class Finder : def __init__ ( self , candidates : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], fullscreen : bool = True , height : Optional [ int ] = None , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , pointer_str : str = DEFAULT_POINTER , prompt_str : str = DEFAULT_PROMPT , output_stream : TextIO = sys . stderr , ): \"\"\" Initializate Finder object Args: candidates: Candidates fullscreen: Full screen mode height: Finder window height format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info pointer_str: Pointer to the current line prompt_str: Input prompt \"\"\" self . fullscreen = fullscreen self . height = height self . format_fn = format_fn self . layout : Layout = layout self . info_style : InfoStyle = info_style self . pointer_str = pointer_str self . no_pointer_str = \" \" * len ( pointer_str ) self . prompt_str = prompt_str self . output_stream = output_stream self . keycodes_actions : Dict [ str , str ] = dict ( ChainMap ( * [{ KEYS [ v ]: k for v in vlist } for k , vlist in ACTIONS . items ()])) # Get the candidates if isinstance ( candidates , Iterator ) or callable ( candidates ): self . get_items_fn : Union [ None , Callable [[], Sequence [ Any ]], Iterator [ Any ]] = candidates self . candidates : Sequence [ Any ] = [] else : self . get_items_fn = None self . candidates = candidates def show ( self , input : Optional [ str ] = None ) -> Any : \"\"\" Open pzp and return the selected element Args: input: initial search string Returns: item: the selected item \"\"\" self . setup ( input = input ) try : while True : self . process_key ( get_char ()) self . apply_filter () self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . cleanup () @property def screen_items ( self ) -> Sequence [ Any ]: \"Candidates to be displayed on the screen\" return self . matching_candidates [ self . offset : self . offset + self . max_candidates ] @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) @property def candidates_len ( self ) -> int : \"Number of candidates\" return len ( self . candidates ) @property def matching_candidates_len ( self ) -> int : \"Number of matching candidates\" return len ( self . matching_candidates ) @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0 @property def prompt_lines ( self ) -> int : \"Number of prompt lines\" return len ( self . prompt_str . split ( f \" { NL } \" )) @property def margin_lines ( self ) -> int : \"Screen margin\" return self . info_lines + self . prompt_lines @property def max_candidates ( self ) -> int : \"Maximun number of candidates printables on the screen\" return self . screen . height - self . margin_lines def setup ( self , input : Optional [ str ] = None ) -> None : \"\"\" Setup Finder execution Args: input: initial search string \"\"\" self . input : str = input or \"\" # Load the candidate list self . refresh_candidates () # Calculate the required height and setup the screen height = self . height if self . height is not None else self . candidates_len + self . margin_lines self . screen : Screen = Screen ( stream = self . output_stream , fullscreen = self . fullscreen , height = height ) # Filter the items, calculate the screen offset self . apply_filter () self . update_screen ( erase = False ) def refresh_candidates ( self ) -> None : \"Load/reload the candidate list\" # Get items if isinstance ( self . get_items_fn , Iterator ): self . candidates = list ( self . get_items_fn ) elif callable ( self . get_items_fn ): self . candidates = list ( self . get_items_fn ()) # Reset selected/offset self . selected : int = 0 self . offset : int = 0 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"page-down\" : # Move one page down self . selected = self . selected + self . max_candidates elif action == \"page-up\" : # Move one page up self . selected = self . selected - self . max_candidates elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch def apply_filter ( self ) -> None : \"Filter the items, calculate the screen offset\" self . matching_candidates : Sequence [ Any ] = list ( filter ( self . match , self . candidates )) # Adject selected self . selected = max ( min ( self . selected , self . matching_candidates_len - 1 ), 0 ) # Calculate the offset if self . selected >= self . offset + self . max_candidates : self . offset = self . selected - self . max_candidates + 1 elif self . selected < self . offset : self . offset = self . selected if self . offset < 0 : self . offset = 0 def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_screen () if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush () def print_items ( self ) -> None : for i , item in enumerate ( self . screen_items ): is_selected = i + self . offset == self . selected if is_selected : self . screen . write ( f \" { ERASE_LINE }{ RED }{ BOLD }{ BLACK_BG }{ self . pointer_str }{ NORMAL } { BOLD }{ self . format_fn ( item ) }{ NORMAL }{ NL } \" ) else : self . screen . write ( f \" { ERASE_LINE }{ BLACK_BG }{ self . no_pointer_str }{ NORMAL } { self . format_fn ( item ) }{ NL } \" ) def print_empty_lines ( self ) -> None : if self . fullscreen : lines = self . max_candidates - self . screen_items_len else : lines = min ( self . candidates_len , self . max_candidates - self . screen_items_len ) self . screen . write ( f \" { NL } \" * lines ) def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ self . matching_candidates_len } / { self . candidates_len }{ NORMAL }{ NL } \" ) def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN }{ self . prompt_str }{ NORMAL } { self . input } \" ) def match ( self , item : Any ) -> bool : return self . input . lower () in self . format_fn ( item ) . lower () def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . matching_candidates [ self . selected ] except IndexError : return None","title":"Finder"},{"location":"api/finder/#pzp.finder.Finder.__init__","text":"Initializate Finder object Parameters: Name Type Description Default candidates Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]] Candidates required fullscreen bool Full screen mode True height Optional [ int ] Finder window height None format_fn Callable [[ Any ], str ] Items format function lambda x: str(x) layout Layout Finder layout Layout.REVERSE_LIST info_style InfoStyle Determines the display style of finder info InfoStyle.DEFAULT pointer_str str Pointer to the current line DEFAULT_POINTER prompt_str str Input prompt DEFAULT_PROMPT Source code in pzp/finder.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def __init__ ( self , candidates : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], fullscreen : bool = True , height : Optional [ int ] = None , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , pointer_str : str = DEFAULT_POINTER , prompt_str : str = DEFAULT_PROMPT , output_stream : TextIO = sys . stderr , ): \"\"\" Initializate Finder object Args: candidates: Candidates fullscreen: Full screen mode height: Finder window height format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info pointer_str: Pointer to the current line prompt_str: Input prompt \"\"\" self . fullscreen = fullscreen self . height = height self . format_fn = format_fn self . layout : Layout = layout self . info_style : InfoStyle = info_style self . pointer_str = pointer_str self . no_pointer_str = \" \" * len ( pointer_str ) self . prompt_str = prompt_str self . output_stream = output_stream self . keycodes_actions : Dict [ str , str ] = dict ( ChainMap ( * [{ KEYS [ v ]: k for v in vlist } for k , vlist in ACTIONS . items ()])) # Get the candidates if isinstance ( candidates , Iterator ) or callable ( candidates ): self . get_items_fn : Union [ None , Callable [[], Sequence [ Any ]], Iterator [ Any ]] = candidates self . candidates : Sequence [ Any ] = [] else : self . get_items_fn = None self . candidates = candidates","title":"__init__()"},{"location":"api/finder/#pzp.finder.Finder.apply_filter","text":"Filter the items, calculate the screen offset Source code in pzp/finder.py 231 232 233 234 235 236 237 238 239 240 241 242 def apply_filter ( self ) -> None : \"Filter the items, calculate the screen offset\" self . matching_candidates : Sequence [ Any ] = list ( filter ( self . match , self . candidates )) # Adject selected self . selected = max ( min ( self . selected , self . matching_candidates_len - 1 ), 0 ) # Calculate the offset if self . selected >= self . offset + self . max_candidates : self . offset = self . selected - self . max_candidates + 1 elif self . selected < self . offset : self . offset = self . selected if self . offset < 0 : self . offset = 0","title":"apply_filter()"},{"location":"api/finder/#pzp.finder.Finder.candidates_len","text":"Number of candidates Source code in pzp/finder.py 150 151 152 153 @property def candidates_len ( self ) -> int : \"Number of candidates\" return len ( self . candidates )","title":"candidates_len()"},{"location":"api/finder/#pzp.finder.Finder.info_lines","text":"Number of info lines Source code in pzp/finder.py 160 161 162 163 @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0","title":"info_lines()"},{"location":"api/finder/#pzp.finder.Finder.margin_lines","text":"Screen margin Source code in pzp/finder.py 170 171 172 173 @property def margin_lines ( self ) -> int : \"Screen margin\" return self . info_lines + self . prompt_lines","title":"margin_lines()"},{"location":"api/finder/#pzp.finder.Finder.matching_candidates_len","text":"Number of matching candidates Source code in pzp/finder.py 155 156 157 158 @property def matching_candidates_len ( self ) -> int : \"Number of matching candidates\" return len ( self . matching_candidates )","title":"matching_candidates_len()"},{"location":"api/finder/#pzp.finder.Finder.max_candidates","text":"Maximun number of candidates printables on the screen Source code in pzp/finder.py 175 176 177 178 @property def max_candidates ( self ) -> int : \"Maximun number of candidates printables on the screen\" return self . screen . height - self . margin_lines","title":"max_candidates()"},{"location":"api/finder/#pzp.finder.Finder.prepare_result","text":"Output the selected item, if any Source code in pzp/finder.py 284 285 286 287 288 289 def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . matching_candidates [ self . selected ] except IndexError : return None","title":"prepare_result()"},{"location":"api/finder/#pzp.finder.Finder.print_info","text":"Print info Source code in pzp/finder.py 272 273 274 275 def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ self . matching_candidates_len } / { self . candidates_len }{ NORMAL }{ NL } \" )","title":"print_info()"},{"location":"api/finder/#pzp.finder.Finder.print_prompt","text":"Print prompt Source code in pzp/finder.py 277 278 279 def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN }{ self . prompt_str }{ NORMAL } { self . input } \" )","title":"print_prompt()"},{"location":"api/finder/#pzp.finder.Finder.process_key","text":"Process the pressed key Source code in pzp/finder.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"page-down\" : # Move one page down self . selected = self . selected + self . max_candidates elif action == \"page-up\" : # Move one page up self . selected = self . selected - self . max_candidates elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch","title":"process_key()"},{"location":"api/finder/#pzp.finder.Finder.prompt_lines","text":"Number of prompt lines Source code in pzp/finder.py 165 166 167 168 @property def prompt_lines ( self ) -> int : \"Number of prompt lines\" return len ( self . prompt_str . split ( f \" { NL } \" ))","title":"prompt_lines()"},{"location":"api/finder/#pzp.finder.Finder.refresh_candidates","text":"Load/reload the candidate list Source code in pzp/finder.py 197 198 199 200 201 202 203 204 205 206 def refresh_candidates ( self ) -> None : \"Load/reload the candidate list\" # Get items if isinstance ( self . get_items_fn , Iterator ): self . candidates = list ( self . get_items_fn ) elif callable ( self . get_items_fn ): self . candidates = list ( self . get_items_fn ()) # Reset selected/offset self . selected : int = 0 self . offset : int = 0","title":"refresh_candidates()"},{"location":"api/finder/#pzp.finder.Finder.screen_items","text":"Candidates to be displayed on the screen Source code in pzp/finder.py 140 141 142 143 @property def screen_items ( self ) -> Sequence [ Any ]: \"Candidates to be displayed on the screen\" return self . matching_candidates [ self . offset : self . offset + self . max_candidates ]","title":"screen_items()"},{"location":"api/finder/#pzp.finder.Finder.screen_items_len","text":"Number of items on the screen Source code in pzp/finder.py 145 146 147 148 @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items )","title":"screen_items_len()"},{"location":"api/finder/#pzp.finder.Finder.setup","text":"Setup Finder execution Parameters: Name Type Description Default input Optional [ str ] initial search string None Source code in pzp/finder.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 def setup ( self , input : Optional [ str ] = None ) -> None : \"\"\" Setup Finder execution Args: input: initial search string \"\"\" self . input : str = input or \"\" # Load the candidate list self . refresh_candidates () # Calculate the required height and setup the screen height = self . height if self . height is not None else self . candidates_len + self . margin_lines self . screen : Screen = Screen ( stream = self . output_stream , fullscreen = self . fullscreen , height = height ) # Filter the items, calculate the screen offset self . apply_filter () self . update_screen ( erase = False )","title":"setup()"},{"location":"api/finder/#pzp.finder.Finder.show","text":"Open pzp and return the selected element Parameters: Name Type Description Default input Optional [ str ] initial search string None Returns: Name Type Description item Any the selected item Source code in pzp/finder.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def show ( self , input : Optional [ str ] = None ) -> Any : \"\"\" Open pzp and return the selected element Args: input: initial search string Returns: item: the selected item \"\"\" self . setup ( input = input ) try : while True : self . process_key ( get_char ()) self . apply_filter () self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . cleanup ()","title":"show()"},{"location":"api/finder/#pzp.finder.Finder.update_screen","text":"Update the screen - erase the old items, print the filtered items and the prompt Source code in pzp/finder.py 244 245 246 247 248 249 250 251 252 253 def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_screen () if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush ()","title":"update_screen()"},{"location":"api/finder/#pzp.finder.InfoStyle","text":"Bases: Enum Display style of finder info Source code in pzp/finder.py 64 65 66 67 68 69 70 class InfoStyle ( Enum ): \"Display style of finder info\" DEFAULT = \"default\" \" Display on the next line to the prompt \" HIDDEN = \"hidden\" \" Do not display finder info\"","title":"InfoStyle"},{"location":"api/finder/#pzp.finder.InfoStyle.DEFAULT","text":"Display on the next line to the prompt","title":"DEFAULT"},{"location":"api/finder/#pzp.finder.InfoStyle.HIDDEN","text":"Do not display finder info","title":"HIDDEN"},{"location":"api/finder/#pzp.finder.Layout","text":"Bases: Enum Finder layouts Source code in pzp/finder.py 57 58 59 60 61 class Layout ( Enum ): \"Finder layouts\" REVERSE_LIST = \"reverse-list\" \" Display from the top of the screen, prompt at the bottom \"","title":"Layout"},{"location":"api/finder/#pzp.finder.Layout.REVERSE_LIST","text":"Display from the top of the screen, prompt at the bottom","title":"REVERSE_LIST"},{"location":"api/module/","text":"__version__ = '0.0.5' module-attribute PZP Version pzp ( candidates , height = None , fullscreen = True , format_fn = lambda x : str ( x ), layout = Layout . REVERSE_LIST , info_style = InfoStyle . DEFAULT , pointer_str = DEFAULT_POINTER , prompt_str = DEFAULT_PROMPT , input = None ) Open pzp and return the selected element Examples: >>> pzp ( candidates = list ( Path ( '.' ) . iterdir ())) PosixPath('README.md') Parameters: Name Type Description Default candidates Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]] Candidates required fullscreen bool Full screen mode True height Optional [ int ] Finder window height None format_fn Callable [[ Any ], str ] Items format function lambda x: str(x) layout Layout Finder layout Layout.REVERSE_LIST info_style InfoStyle Determines the display style of finder info InfoStyle.DEFAULT pointer_str str Pointer to the current line DEFAULT_POINTER prompt_str str Input prompt DEFAULT_PROMPT Returns: Name Type Description item Any the selected item Source code in pzp/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def pzp ( candidates : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], height : Optional [ int ] = None , fullscreen : bool = True , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , pointer_str : str = DEFAULT_POINTER , prompt_str : str = DEFAULT_PROMPT , input : Optional [ str ] = None , ) -> Any : \"\"\" Open pzp and return the selected element Examples: >>> pzp(candidates=list(Path('.').iterdir())) PosixPath('README.md') Args: candidates: Candidates fullscreen: Full screen mode height: Finder window height format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info pointer_str: Pointer to the current line prompt_str: Input prompt Returns: item: the selected item \"\"\" finder = Finder ( candidates = candidates , fullscreen = fullscreen , height = height , format_fn = format_fn , layout = layout , info_style = info_style , pointer_str = pointer_str , prompt_str = prompt_str , ) return finder . show ( input = input )","title":"pzp"},{"location":"api/module/#pzp.__version__","text":"PZP Version","title":"__version__"},{"location":"api/module/#pzp.pzp","text":"Open pzp and return the selected element Examples: >>> pzp ( candidates = list ( Path ( '.' ) . iterdir ())) PosixPath('README.md') Parameters: Name Type Description Default candidates Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]] Candidates required fullscreen bool Full screen mode True height Optional [ int ] Finder window height None format_fn Callable [[ Any ], str ] Items format function lambda x: str(x) layout Layout Finder layout Layout.REVERSE_LIST info_style InfoStyle Determines the display style of finder info InfoStyle.DEFAULT pointer_str str Pointer to the current line DEFAULT_POINTER prompt_str str Input prompt DEFAULT_PROMPT Returns: Name Type Description item Any the selected item Source code in pzp/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def pzp ( candidates : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], height : Optional [ int ] = None , fullscreen : bool = True , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , pointer_str : str = DEFAULT_POINTER , prompt_str : str = DEFAULT_PROMPT , input : Optional [ str ] = None , ) -> Any : \"\"\" Open pzp and return the selected element Examples: >>> pzp(candidates=list(Path('.').iterdir())) PosixPath('README.md') Args: candidates: Candidates fullscreen: Full screen mode height: Finder window height format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info pointer_str: Pointer to the current line prompt_str: Input prompt Returns: item: the selected item \"\"\" finder = Finder ( candidates = candidates , fullscreen = fullscreen , height = height , format_fn = format_fn , layout = layout , info_style = info_style , pointer_str = pointer_str , prompt_str = prompt_str , ) return finder . show ( input = input )","title":"pzp()"},{"location":"api/screen/","text":"DEFAULT_HEIGHT = 24 module-attribute Default screen height DEFAULT_WIDTH = 80 module-attribute Default screen width Screen Source code in pzp/screen.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class Screen : def __init__ ( self , stream : TextIO = sys . stderr , fullscreen : bool = True , height : Optional [ int ] = None ): \"\"\" Initialize screen Args: stream: Output stream fullscreen: Full screen mode height: Screen height \"\"\" self . stream : TextIO = stream self . data : List [ str ] = [] self . fullscreen = fullscreen if self . fullscreen or height is None : self . height : int = self . get_terminal_height () else : self . height = min ( height , self . get_terminal_height ()) # Save cursor position self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush () @classmethod def get_terminal_height ( cls ) -> int : return shutil . get_terminal_size ( fallback = ( DEFAULT_WIDTH , DEFAULT_HEIGHT )) . lines def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line ) def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush () def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . erase_screen () if self . fullscreen : self . write ( f \" { CURSOR_RESTORE_POS } \" ) self . move_up ( self . height - 1 ) self . flush () def erase_screen ( self ) -> None : \"Erase the screen\" lines : int = self . height - 1 self . erase_lines ( lines ) def erase_lines ( self , lines : int ) -> None : \"\"\" Erase n lines Args: lines: number of lines to be erased \"\"\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines ) def move_up ( self , lines : int ) -> None : \"\"\" Move cursor up If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } A\" ) def move_down ( self , lines : int ) -> None : \"\"\" Move cursor down If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } B\" ) __init__ ( stream = sys . stderr , fullscreen = True , height = None ) Initialize screen Parameters: Name Type Description Default stream TextIO Output stream sys.stderr fullscreen bool Full screen mode True height Optional [ int ] Screen height None Source code in pzp/screen.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , stream : TextIO = sys . stderr , fullscreen : bool = True , height : Optional [ int ] = None ): \"\"\" Initialize screen Args: stream: Output stream fullscreen: Full screen mode height: Screen height \"\"\" self . stream : TextIO = stream self . data : List [ str ] = [] self . fullscreen = fullscreen if self . fullscreen or height is None : self . height : int = self . get_terminal_height () else : self . height = min ( height , self . get_terminal_height ()) # Save cursor position self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush () cleanup () Clean screen and restore cursor position Source code in pzp/screen.py 68 69 70 71 72 73 74 def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . erase_screen () if self . fullscreen : self . write ( f \" { CURSOR_RESTORE_POS } \" ) self . move_up ( self . height - 1 ) self . flush () erase_lines ( lines ) Erase n lines Parameters: Name Type Description Default lines int number of lines to be erased required Source code in pzp/screen.py 81 82 83 84 85 86 87 88 89 90 def erase_lines ( self , lines : int ) -> None : \"\"\" Erase n lines Args: lines: number of lines to be erased \"\"\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines ) erase_screen () Erase the screen Source code in pzp/screen.py 76 77 78 79 def erase_screen ( self ) -> None : \"Erase the screen\" lines : int = self . height - 1 self . erase_lines ( lines ) flush () Write data to the stream and flush it Source code in pzp/screen.py 62 63 64 65 66 def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush () move_down ( lines ) Move cursor down If the cursor is already at the edge of the screen, this has no effect. Parameters: Name Type Description Default lines int number of lines required Source code in pzp/screen.py 102 103 104 105 106 107 108 109 110 def move_down ( self , lines : int ) -> None : \"\"\" Move cursor down If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } B\" ) move_up ( lines ) Move cursor up If the cursor is already at the edge of the screen, this has no effect. Parameters: Name Type Description Default lines int number of lines required Source code in pzp/screen.py 92 93 94 95 96 97 98 99 100 def move_up ( self , lines : int ) -> None : \"\"\" Move cursor up If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } A\" ) write ( line ) Add data to be written on the stream Source code in pzp/screen.py 58 59 60 def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line )","title":"pzp.screen"},{"location":"api/screen/#pzp.screen.DEFAULT_HEIGHT","text":"Default screen height","title":"DEFAULT_HEIGHT"},{"location":"api/screen/#pzp.screen.DEFAULT_WIDTH","text":"Default screen width","title":"DEFAULT_WIDTH"},{"location":"api/screen/#pzp.screen.Screen","text":"Source code in pzp/screen.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class Screen : def __init__ ( self , stream : TextIO = sys . stderr , fullscreen : bool = True , height : Optional [ int ] = None ): \"\"\" Initialize screen Args: stream: Output stream fullscreen: Full screen mode height: Screen height \"\"\" self . stream : TextIO = stream self . data : List [ str ] = [] self . fullscreen = fullscreen if self . fullscreen or height is None : self . height : int = self . get_terminal_height () else : self . height = min ( height , self . get_terminal_height ()) # Save cursor position self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush () @classmethod def get_terminal_height ( cls ) -> int : return shutil . get_terminal_size ( fallback = ( DEFAULT_WIDTH , DEFAULT_HEIGHT )) . lines def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line ) def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush () def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . erase_screen () if self . fullscreen : self . write ( f \" { CURSOR_RESTORE_POS } \" ) self . move_up ( self . height - 1 ) self . flush () def erase_screen ( self ) -> None : \"Erase the screen\" lines : int = self . height - 1 self . erase_lines ( lines ) def erase_lines ( self , lines : int ) -> None : \"\"\" Erase n lines Args: lines: number of lines to be erased \"\"\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines ) def move_up ( self , lines : int ) -> None : \"\"\" Move cursor up If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } A\" ) def move_down ( self , lines : int ) -> None : \"\"\" Move cursor down If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } B\" )","title":"Screen"},{"location":"api/screen/#pzp.screen.Screen.__init__","text":"Initialize screen Parameters: Name Type Description Default stream TextIO Output stream sys.stderr fullscreen bool Full screen mode True height Optional [ int ] Screen height None Source code in pzp/screen.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 def __init__ ( self , stream : TextIO = sys . stderr , fullscreen : bool = True , height : Optional [ int ] = None ): \"\"\" Initialize screen Args: stream: Output stream fullscreen: Full screen mode height: Screen height \"\"\" self . stream : TextIO = stream self . data : List [ str ] = [] self . fullscreen = fullscreen if self . fullscreen or height is None : self . height : int = self . get_terminal_height () else : self . height = min ( height , self . get_terminal_height ()) # Save cursor position self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush ()","title":"__init__()"},{"location":"api/screen/#pzp.screen.Screen.cleanup","text":"Clean screen and restore cursor position Source code in pzp/screen.py 68 69 70 71 72 73 74 def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . erase_screen () if self . fullscreen : self . write ( f \" { CURSOR_RESTORE_POS } \" ) self . move_up ( self . height - 1 ) self . flush ()","title":"cleanup()"},{"location":"api/screen/#pzp.screen.Screen.erase_lines","text":"Erase n lines Parameters: Name Type Description Default lines int number of lines to be erased required Source code in pzp/screen.py 81 82 83 84 85 86 87 88 89 90 def erase_lines ( self , lines : int ) -> None : \"\"\" Erase n lines Args: lines: number of lines to be erased \"\"\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines )","title":"erase_lines()"},{"location":"api/screen/#pzp.screen.Screen.erase_screen","text":"Erase the screen Source code in pzp/screen.py 76 77 78 79 def erase_screen ( self ) -> None : \"Erase the screen\" lines : int = self . height - 1 self . erase_lines ( lines )","title":"erase_screen()"},{"location":"api/screen/#pzp.screen.Screen.flush","text":"Write data to the stream and flush it Source code in pzp/screen.py 62 63 64 65 66 def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush ()","title":"flush()"},{"location":"api/screen/#pzp.screen.Screen.move_down","text":"Move cursor down If the cursor is already at the edge of the screen, this has no effect. Parameters: Name Type Description Default lines int number of lines required Source code in pzp/screen.py 102 103 104 105 106 107 108 109 110 def move_down ( self , lines : int ) -> None : \"\"\" Move cursor down If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } B\" )","title":"move_down()"},{"location":"api/screen/#pzp.screen.Screen.move_up","text":"Move cursor up If the cursor is already at the edge of the screen, this has no effect. Parameters: Name Type Description Default lines int number of lines required Source code in pzp/screen.py 92 93 94 95 96 97 98 99 100 def move_up ( self , lines : int ) -> None : \"\"\" Move cursor up If the cursor is already at the edge of the screen, this has no effect. Args: lines: number of lines \"\"\" self . write ( f \" { ESC } [ { lines } A\" )","title":"move_up()"},{"location":"api/screen/#pzp.screen.Screen.write","text":"Add data to be written on the stream Source code in pzp/screen.py 58 59 60 def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line )","title":"write()"},{"location":"examples/file_selector/","text":"#!/usr/bin/env python from pathlib import Path from pzp import pzp def main(): item = pzp(candidates=list(Path('.').iterdir())) print(str(item) if item else '') if __name__ == \"__main__\": main()","title":"file selector"},{"location":"examples/number_selector/","text":"#!/usr/bin/env python from pzp import pzp def num_format(item): return f\"{item}\" def main(): line = pzp(candidates=range(0, 1000), format_fn=num_format) print(line) if __name__ == \"__main__\": main()","title":"number selector"}]}