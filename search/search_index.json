{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pzp","title":"Pzp Docs"},{"location":"#pzp","text":"","title":"pzp"},{"location":"license/","text":"The MIT License (MIT) Copyright (c) 2013-2022 Andrea Bonomi andrea.bonomi@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/finder/","text":"Finder Source code in pzp/finder.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Finder : def __init__ ( self , items : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], max_lines : Optional [ int ] = None , margin : int = DEFAULT_MARGIN , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , ): if max_lines is None : self . max_lines = os . get_terminal_size () . lines - margin else : self . max_lines = max_lines if isinstance ( items , Iterator ): self . get_items_fn : Union [ None , Callable [[], Sequence [ Any ]], Iterator [ Any ]] = items self . items : Sequence [ Any ] = list ( self . get_items_fn ) self . filtered_items : Sequence [ Any ] = self . items elif callable ( items ): self . get_items_fn = items self . filtered_items = self . items = self . get_items_fn () else : self . get_items_fn = None self . filtered_items = self . items = items self . format_fn = format_fn self . screen : Screen = Screen () self . layout : Layout = layout self . info_style : InfoStyle = info_style self . keycodes_actions : Dict [ str , str ] = dict ( ChainMap ( * [{ KEYS [ v ]: k for v in vlist } for k , vlist in ACTIONS . items ()])) def show ( self ) -> Any : \"\"\" Open pzp and return the selected element Returns: item: the selected item \"\"\" self . input : str = \"\" self . selected : int = 0 self . screen_items : List [ Any ] = [] self . screen . init () self . update_screen ( erase = False ) try : while True : self . process_key ( get_char ()) self . filtered_items = list ( filter ( self . match , self . items )) self . selected = max ( min ( self . selected , len ( self . filtered_items ) - 1 ), 0 ) self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen . cleanup () @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) if self . screen_items else 0 @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen_items = [ x for x in itertools . islice ( self . filtered_items , None , self . max_lines )] if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush () def print_items ( self ) -> None : for i , item in enumerate ( self . screen_items ): if i == self . selected : self . screen . write ( f \" { ERASE_LINE }{ RED }{ BOLD } > { NORMAL } { BOLD }{ self . format_fn ( item ) }{ NORMAL }{ NL } \" ) else : self . screen . write ( f \" { ERASE_LINE } { self . format_fn ( item ) }{ NL } \" ) def print_empty_lines ( self ) -> None : self . screen . write ( f \" { NL } \" * ( min ( len ( self . items ), self . max_lines - self . screen_items_len ))) def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ len ( self . filtered_items ) } / { len ( self . items ) }{ NORMAL }{ NL } \" ) def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN } > { NORMAL } { self . input } \" ) def match ( self , item : Any ) -> bool : return self . input . lower () in self . format_fn ( item ) . lower () def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . filtered_items [ self . selected ] except IndexError : return None info_lines () property Number of info lines Source code in pzp/finder.py 130 131 132 133 @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0 prepare_result () Output the selected item, if any Source code in pzp/finder.py 188 189 190 191 192 193 def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . filtered_items [ self . selected ] except IndexError : return None print_info () Print info Source code in pzp/finder.py 176 177 178 179 def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ len ( self . filtered_items ) } / { len ( self . items ) }{ NORMAL }{ NL } \" ) print_prompt () Print prompt Source code in pzp/finder.py 181 182 183 def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN } > { NORMAL } { self . input } \" ) process_key ( ch ) Process the pressed key Source code in pzp/finder.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch screen_items_len () property Number of items on the screen Source code in pzp/finder.py 125 126 127 128 @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) if self . screen_items else 0 show () Open pzp and return the selected element Returns: Name Type Description item Any the selected item Source code in pzp/finder.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def show ( self ) -> Any : \"\"\" Open pzp and return the selected element Returns: item: the selected item \"\"\" self . input : str = \"\" self . selected : int = 0 self . screen_items : List [ Any ] = [] self . screen . init () self . update_screen ( erase = False ) try : while True : self . process_key ( get_char ()) self . filtered_items = list ( filter ( self . match , self . items )) self . selected = max ( min ( self . selected , len ( self . filtered_items ) - 1 ), 0 ) self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen . cleanup () update_screen ( erase = True ) Update the screen - erase the old items, print the filtered items and the prompt Source code in pzp/finder.py 154 155 156 157 158 159 160 161 162 163 164 def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen_items = [ x for x in itertools . islice ( self . filtered_items , None , self . max_lines )] if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush () InfoStyle Bases: Enum Display style of finder info Source code in pzp/finder.py 60 61 62 63 64 65 66 class InfoStyle ( Enum ): \"Display style of finder info\" DEFAULT = \"default\" \" Display on the next line to the prompt \" HIDDEN = \"hidden\" \" Do not display finder info\" DEFAULT = 'default' class-attribute Display on the next line to the prompt HIDDEN = 'hidden' class-attribute Do not display finder info Layout Bases: Enum Finder layouts Source code in pzp/finder.py 54 55 56 57 class Layout ( Enum ): \"Finder layouts\" REVERSE_LIST = \"reverse-list\" \" Display from the top of the screen, prompt at the bottom \" REVERSE_LIST = 'reverse-list' class-attribute Display from the top of the screen, prompt at the bottom","title":"pzp.finder"},{"location":"api/finder/#pzp.finder.Finder","text":"Source code in pzp/finder.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Finder : def __init__ ( self , items : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], max_lines : Optional [ int ] = None , margin : int = DEFAULT_MARGIN , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , ): if max_lines is None : self . max_lines = os . get_terminal_size () . lines - margin else : self . max_lines = max_lines if isinstance ( items , Iterator ): self . get_items_fn : Union [ None , Callable [[], Sequence [ Any ]], Iterator [ Any ]] = items self . items : Sequence [ Any ] = list ( self . get_items_fn ) self . filtered_items : Sequence [ Any ] = self . items elif callable ( items ): self . get_items_fn = items self . filtered_items = self . items = self . get_items_fn () else : self . get_items_fn = None self . filtered_items = self . items = items self . format_fn = format_fn self . screen : Screen = Screen () self . layout : Layout = layout self . info_style : InfoStyle = info_style self . keycodes_actions : Dict [ str , str ] = dict ( ChainMap ( * [{ KEYS [ v ]: k for v in vlist } for k , vlist in ACTIONS . items ()])) def show ( self ) -> Any : \"\"\" Open pzp and return the selected element Returns: item: the selected item \"\"\" self . input : str = \"\" self . selected : int = 0 self . screen_items : List [ Any ] = [] self . screen . init () self . update_screen ( erase = False ) try : while True : self . process_key ( get_char ()) self . filtered_items = list ( filter ( self . match , self . items )) self . selected = max ( min ( self . selected , len ( self . filtered_items ) - 1 ), 0 ) self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen . cleanup () @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) if self . screen_items else 0 @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen_items = [ x for x in itertools . islice ( self . filtered_items , None , self . max_lines )] if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush () def print_items ( self ) -> None : for i , item in enumerate ( self . screen_items ): if i == self . selected : self . screen . write ( f \" { ERASE_LINE }{ RED }{ BOLD } > { NORMAL } { BOLD }{ self . format_fn ( item ) }{ NORMAL }{ NL } \" ) else : self . screen . write ( f \" { ERASE_LINE } { self . format_fn ( item ) }{ NL } \" ) def print_empty_lines ( self ) -> None : self . screen . write ( f \" { NL } \" * ( min ( len ( self . items ), self . max_lines - self . screen_items_len ))) def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ len ( self . filtered_items ) } / { len ( self . items ) }{ NORMAL }{ NL } \" ) def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN } > { NORMAL } { self . input } \" ) def match ( self , item : Any ) -> bool : return self . input . lower () in self . format_fn ( item ) . lower () def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . filtered_items [ self . selected ] except IndexError : return None","title":"Finder"},{"location":"api/finder/#pzp.finder.Finder.info_lines","text":"Number of info lines Source code in pzp/finder.py 130 131 132 133 @property def info_lines ( self ) -> int : \"Number of info lines\" return 1 if self . info_style == InfoStyle . DEFAULT else 0","title":"info_lines()"},{"location":"api/finder/#pzp.finder.Finder.prepare_result","text":"Output the selected item, if any Source code in pzp/finder.py 188 189 190 191 192 193 def prepare_result ( self ) -> Any : \"Output the selected item, if any\" try : return self . filtered_items [ self . selected ] except IndexError : return None","title":"prepare_result()"},{"location":"api/finder/#pzp.finder.Finder.print_info","text":"Print info Source code in pzp/finder.py 176 177 178 179 def print_info ( self ) -> None : \"Print info\" if self . info_style == InfoStyle . DEFAULT : self . screen . write ( f \" { ERASE_LINE }{ YELLOW }{ len ( self . filtered_items ) } / { len ( self . items ) }{ NORMAL }{ NL } \" )","title":"print_info()"},{"location":"api/finder/#pzp.finder.Finder.print_prompt","text":"Print prompt Source code in pzp/finder.py 181 182 183 def print_prompt ( self ) -> None : \"Print prompt\" self . screen . write ( f \" { ERASE_LINE }{ CYAN } > { NORMAL } { self . input } \" )","title":"print_prompt()"},{"location":"api/finder/#pzp.finder.Finder.process_key","text":"Process the pressed key Source code in pzp/finder.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def process_key ( self , ch : str ) -> None : \"Process the pressed key\" action = self . keycodes_actions . get ( ch ) if action == \"accept\" : # Confirm raise Confirm elif action == \"abort\" : # Cancel raise Cancel elif action == \"down\" : # Move one line down self . selected = self . selected + 1 elif action == \"up\" : # Move one line up self . selected = self . selected - 1 elif action == \"backward-delete-char\" : # Delete one characted if self . input : self . input = self . input [: - 1 ] elif action == \"ignore\" : # Skip pass elif ch >= SPACE : # Append the character to line self . input = self . input + ch","title":"process_key()"},{"location":"api/finder/#pzp.finder.Finder.screen_items_len","text":"Number of items on the screen Source code in pzp/finder.py 125 126 127 128 @property def screen_items_len ( self ) -> int : \"Number of items on the screen\" return len ( self . screen_items ) if self . screen_items else 0","title":"screen_items_len()"},{"location":"api/finder/#pzp.finder.Finder.show","text":"Open pzp and return the selected element Returns: Name Type Description item Any the selected item Source code in pzp/finder.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def show ( self ) -> Any : \"\"\" Open pzp and return the selected element Returns: item: the selected item \"\"\" self . input : str = \"\" self . selected : int = 0 self . screen_items : List [ Any ] = [] self . screen . init () self . update_screen ( erase = False ) try : while True : self . process_key ( get_char ()) self . filtered_items = list ( filter ( self . match , self . items )) self . selected = max ( min ( self . selected , len ( self . filtered_items ) - 1 ), 0 ) self . update_screen () except Confirm : return self . prepare_result () except Cancel : return None finally : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen . cleanup ()","title":"show()"},{"location":"api/finder/#pzp.finder.Finder.update_screen","text":"Update the screen - erase the old items, print the filtered items and the prompt Source code in pzp/finder.py 154 155 156 157 158 159 160 161 162 163 164 def update_screen ( self , erase : bool = True ) -> None : \"Update the screen - erase the old items, print the filtered items and the prompt\" if erase : self . screen . erase_lines ( self . max_lines + self . info_lines ) self . screen_items = [ x for x in itertools . islice ( self . filtered_items , None , self . max_lines )] if self . layout == Layout . REVERSE_LIST : self . print_items () self . print_empty_lines () self . print_info () self . print_prompt () self . screen . flush ()","title":"update_screen()"},{"location":"api/finder/#pzp.finder.InfoStyle","text":"Bases: Enum Display style of finder info Source code in pzp/finder.py 60 61 62 63 64 65 66 class InfoStyle ( Enum ): \"Display style of finder info\" DEFAULT = \"default\" \" Display on the next line to the prompt \" HIDDEN = \"hidden\" \" Do not display finder info\"","title":"InfoStyle"},{"location":"api/finder/#pzp.finder.InfoStyle.DEFAULT","text":"Display on the next line to the prompt","title":"DEFAULT"},{"location":"api/finder/#pzp.finder.InfoStyle.HIDDEN","text":"Do not display finder info","title":"HIDDEN"},{"location":"api/finder/#pzp.finder.Layout","text":"Bases: Enum Finder layouts Source code in pzp/finder.py 54 55 56 57 class Layout ( Enum ): \"Finder layouts\" REVERSE_LIST = \"reverse-list\" \" Display from the top of the screen, prompt at the bottom \"","title":"Layout"},{"location":"api/finder/#pzp.finder.Layout.REVERSE_LIST","text":"Display from the top of the screen, prompt at the bottom","title":"REVERSE_LIST"},{"location":"api/module/","text":"__version__ = '0.0.1' module-attribute PZP Version pzp ( items , max_lines = None , format_fn = lambda x : str ( x ), layout = Layout . REVERSE_LIST , info_style = InfoStyle . DEFAULT ) Open pzp and return the selected element Examples: >>> pzp ( items = list ( Path ( '.' ) . iterdir ())) PosixPath('README.md') Parameters: Name Type Description Default items Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]] Items required max_lines Optional [ int ] Max display lines None format_fn Callable [[ Any ], str ] Items format function lambda x: str(x) layout Layout Finder layout Layout.REVERSE_LIST info_style InfoStyle Determines the display style of finder info InfoStyle.DEFAULT Source code in pzp/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def pzp ( items : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], max_lines : Optional [ int ] = None , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , ) -> Any : \"\"\" Open pzp and return the selected element Examples: >>> pzp(items=list(Path('.').iterdir())) PosixPath('README.md') Args: items: Items max_lines: Max display lines format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info \"\"\" finder = Finder ( items = items , max_lines = max_lines , format_fn = format_fn , layout = layout , info_style = info_style ) return finder . show ()","title":"pzp"},{"location":"api/module/#pzp.__version__","text":"PZP Version","title":"__version__"},{"location":"api/module/#pzp.pzp","text":"Open pzp and return the selected element Examples: >>> pzp ( items = list ( Path ( '.' ) . iterdir ())) PosixPath('README.md') Parameters: Name Type Description Default items Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]] Items required max_lines Optional [ int ] Max display lines None format_fn Callable [[ Any ], str ] Items format function lambda x: str(x) layout Layout Finder layout Layout.REVERSE_LIST info_style InfoStyle Determines the display style of finder info InfoStyle.DEFAULT Source code in pzp/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def pzp ( items : Union [ Callable [[], Sequence [ Any ]], Iterator [ Any ], Sequence [ Any ]], max_lines : Optional [ int ] = None , format_fn : Callable [[ Any ], str ] = lambda x : str ( x ), layout : Layout = Layout . REVERSE_LIST , info_style : InfoStyle = InfoStyle . DEFAULT , ) -> Any : \"\"\" Open pzp and return the selected element Examples: >>> pzp(items=list(Path('.').iterdir())) PosixPath('README.md') Args: items: Items max_lines: Max display lines format_fn: Items format function layout: Finder layout info_style: Determines the display style of finder info \"\"\" finder = Finder ( items = items , max_lines = max_lines , format_fn = format_fn , layout = layout , info_style = info_style ) return finder . show ()","title":"pzp()"},{"location":"api/screen/","text":"Screen Source code in pzp/screen.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Screen : def __init__ ( self , stream : TextIO = sys . stderr ): \"\"\" Initialize screen Args: stream: output stream \"\"\" self . stream = stream self . data : List [ str ] = [] def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line ) def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush () def init ( self ) -> None : \"Save cursor position\" self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush () def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . write ( f \" { CURSOR_RESTORE_POS }{ ERASE_LINE }{ CURSOR_SAVE_POS } \" ) self . flush () def erase_lines ( self , lines : int ) -> None : \"Erase n lines\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines ) def move_up ( self , lines : int ) -> None : self . write ( f \" { ESC } [ { lines } A\" ) __init__ ( stream = sys . stderr ) Initialize screen Parameters: Name Type Description Default stream TextIO output stream sys.stderr Source code in pzp/screen.py 46 47 48 49 50 51 52 53 54 def __init__ ( self , stream : TextIO = sys . stderr ): \"\"\" Initialize screen Args: stream: output stream \"\"\" self . stream = stream self . data : List [ str ] = [] cleanup () Clean screen and restore cursor position Source code in pzp/screen.py 71 72 73 74 def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . write ( f \" { CURSOR_RESTORE_POS }{ ERASE_LINE }{ CURSOR_SAVE_POS } \" ) self . flush () erase_lines ( lines ) Erase n lines Source code in pzp/screen.py 76 77 78 79 80 def erase_lines ( self , lines : int ) -> None : \"Erase n lines\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines ) flush () Write data to the stream and flush it Source code in pzp/screen.py 60 61 62 63 64 def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush () init () Save cursor position Source code in pzp/screen.py 66 67 68 69 def init ( self ) -> None : \"Save cursor position\" self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush () write ( line ) Add data to be written on the stream Source code in pzp/screen.py 56 57 58 def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line )","title":"pzp.screen"},{"location":"api/screen/#pzp.screen.Screen","text":"Source code in pzp/screen.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Screen : def __init__ ( self , stream : TextIO = sys . stderr ): \"\"\" Initialize screen Args: stream: output stream \"\"\" self . stream = stream self . data : List [ str ] = [] def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line ) def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush () def init ( self ) -> None : \"Save cursor position\" self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush () def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . write ( f \" { CURSOR_RESTORE_POS }{ ERASE_LINE }{ CURSOR_SAVE_POS } \" ) self . flush () def erase_lines ( self , lines : int ) -> None : \"Erase n lines\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines ) def move_up ( self , lines : int ) -> None : self . write ( f \" { ESC } [ { lines } A\" )","title":"Screen"},{"location":"api/screen/#pzp.screen.Screen.__init__","text":"Initialize screen Parameters: Name Type Description Default stream TextIO output stream sys.stderr Source code in pzp/screen.py 46 47 48 49 50 51 52 53 54 def __init__ ( self , stream : TextIO = sys . stderr ): \"\"\" Initialize screen Args: stream: output stream \"\"\" self . stream = stream self . data : List [ str ] = []","title":"__init__()"},{"location":"api/screen/#pzp.screen.Screen.cleanup","text":"Clean screen and restore cursor position Source code in pzp/screen.py 71 72 73 74 def cleanup ( self ) -> None : \"Clean screen and restore cursor position\" self . write ( f \" { CURSOR_RESTORE_POS }{ ERASE_LINE }{ CURSOR_SAVE_POS } \" ) self . flush ()","title":"cleanup()"},{"location":"api/screen/#pzp.screen.Screen.erase_lines","text":"Erase n lines Source code in pzp/screen.py 76 77 78 79 80 def erase_lines ( self , lines : int ) -> None : \"Erase n lines\" self . move_up ( lines ) self . write ( f \" { ERASE_LINE }{ NL } \" * lines ) self . move_up ( lines )","title":"erase_lines()"},{"location":"api/screen/#pzp.screen.Screen.flush","text":"Write data to the stream and flush it Source code in pzp/screen.py 60 61 62 63 64 def flush ( self ) -> None : \"Write data to the stream and flush it\" self . stream . write ( \"\" . join ( self . data )) self . data = [] self . stream . flush ()","title":"flush()"},{"location":"api/screen/#pzp.screen.Screen.init","text":"Save cursor position Source code in pzp/screen.py 66 67 68 69 def init ( self ) -> None : \"Save cursor position\" self . write ( f \" { CURSOR_SAVE_POS } \" ) self . flush ()","title":"init()"},{"location":"api/screen/#pzp.screen.Screen.write","text":"Add data to be written on the stream Source code in pzp/screen.py 56 57 58 def write ( self , line : str ) -> None : \"Add data to be written on the stream\" self . data . append ( line )","title":"write()"},{"location":"examples/file_selector/","text":"#!/usr/bin/env python from pathlib import Path from pzp import pzp def main(): item = pzp(items=list(Path('.').iterdir())) print(str(item) if item else '') if __name__ == \"__main__\": main()","title":"file selector"},{"location":"examples/number_selector/","text":"#!/usr/bin/env python from pzp import pzp def num_format(item): return f\"{item}\" def main(): line = pzp(range(0, 1000), format_fn=num_format) print(line) if __name__ == \"__main__\": main()","title":"number selector"}]}